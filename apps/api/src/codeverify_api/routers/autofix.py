"""Agentic auto-fix pipeline API router."""

import difflib
import time
import uuid
from typing import Any

from fastapi import APIRouter, HTTPException, Query, status
from pydantic import BaseModel, Field

router = APIRouter()


class Finding(BaseModel):
    finding_id: str
    type: str = Field(description="Finding type: null_safety, array_bounds, integer_overflow, etc.")
    severity: str
    message: str
    file_path: str
    line_number: int
    code_snippet: str | None = None


class FixRequest(BaseModel):
    code: str = Field(description="Source code containing the issue")
    finding: Finding
    language: str = Field(default="python")
    auto_create_pr: bool = Field(default=False, description="Auto-create a PR with the fix")
    require_verification: bool = Field(default=True, description="Require Z3 verification of the fix")


class CodeFix(BaseModel):
    fix_id: str
    finding_id: str
    file_path: str
    original_code: str
    fixed_code: str
    diff: str
    explanation: str
    confidence: str = Field(description="Confidence: low, medium, high, very_high")
    status: str = Field(description="Status: pending, generating, verifying, verified, failed")
    verification_result: dict[str, Any] | None = None
    generated_test: str | None = None


class BatchFixRequest(BaseModel):
    code_files: dict[str, str] = Field(description="Map of file_path to code content")
    findings: list[Finding]
    language: str = Field(default="python")


class BatchFixResponse(BaseModel):
    fixes: list[CodeFix]
    total_findings: int
    successful_fixes: int
    failed_fixes: int
    fix_rate: float


class FixSummary(BaseModel):
    total_fixes: int
    by_status: dict[str, int]
    by_confidence: dict[str, int]
    average_confidence: str


# In-memory fix storage
_fixes: dict[str, dict[str, Any]] = {}

# Fix templates for common issues
FIX_TEMPLATES: dict[str, dict[str, str]] = {
    "null_safety": {
        "python": 'if {var} is not None:\n    {original_line}',
        "typescript": 'if ({var} !== null && {var} !== undefined) {{\n    {original_line}\n}}',
        "go": 'if {var} != nil {{\n    {original_line}\n}}',
        "java": 'if ({var} != null) {{\n    {original_line}\n}}',
    },
    "division_by_zero": {
        "python": 'if {divisor} != 0:\n    {original_line}\nelse:\n    raise ValueError("Division by zero")',
        "typescript": 'if ({divisor} !== 0) {{\n    {original_line}\n}} else {{\n    throw new Error("Division by zero");\n}}',
        "go": 'if {divisor} != 0 {{\n    {original_line}\n}} else {{\n    return fmt.Errorf("division by zero")\n}}',
        "java": 'if ({divisor} != 0) {{\n    {original_line}\n}} else {{\n    throw new ArithmeticException("Division by zero");\n}}',
    },
    "array_bounds": {
        "python": 'if 0 <= {index} < len({array}):\n    {original_line}',
        "typescript": 'if ({index} >= 0 && {index} < {array}.length) {{\n    {original_line}\n}}',
        "go": 'if {index} >= 0 && {index} < len({array}) {{\n    {original_line}\n}}',
        "java": 'if ({index} >= 0 && {index} < {array}.length) {{\n    {original_line}\n}}',
    },
}

# Test templates
TEST_TEMPLATES: dict[str, dict[str, str]] = {
    "python": '''def test_{function_name}_{finding_type}():
    """Regression test for {finding_type} in {function_name}.

    Generated by CodeVerify auto-fix pipeline.
    Finding: {message}
    """
    # Test that the fix handles the edge case
    {test_body}
''',
    "typescript": '''test('{function_name} handles {finding_type}', () => {{
    // Regression test generated by CodeVerify auto-fix pipeline
    // Finding: {message}
    {test_body}
}});
''',
}


def _generate_diff(original: str, fixed: str, file_path: str) -> str:
    """Generate a unified diff between original and fixed code."""
    original_lines = original.splitlines(keepends=True)
    fixed_lines = fixed.splitlines(keepends=True)
    diff = difflib.unified_diff(
        original_lines,
        fixed_lines,
        fromfile=f"a/{file_path}",
        tofile=f"b/{file_path}",
    )
    return "".join(diff)


def _apply_simple_fix(code: str, finding: Finding, language: str) -> tuple[str, str, str]:
    """Apply a template-based fix for common issue types. Returns (fixed_code, explanation, confidence)."""
    lines = code.splitlines()
    line_idx = finding.line_number - 1

    if line_idx < 0 or line_idx >= len(lines):
        return code, "Could not locate the issue line", "low"

    original_line = lines[line_idx]
    indent = len(original_line) - len(original_line.lstrip())
    indent_str = original_line[:indent]

    templates = FIX_TEMPLATES.get(finding.type, {})
    template = templates.get(language)

    if not template:
        # Generic fix: add a comment warning
        lines[line_idx] = f"{indent_str}# FIXME: {finding.message}\n{original_line}"
        return "\n".join(lines), f"Added warning comment for: {finding.message}", "low"

    # Apply template with indentation
    fixed_line = template.format(
        var="value",
        divisor="divisor",
        index="index",
        array="items",
        original_line=original_line.strip(),
    )
    fixed_lines = [f"{indent_str}{l}" for l in fixed_line.splitlines()]
    lines[line_idx] = "\n".join(fixed_lines)

    explanation = f"Added {finding.type} guard to prevent {finding.message}"
    return "\n".join(lines), explanation, "high"


def _generate_test(fix_data: dict[str, Any], language: str) -> str | None:
    """Generate a regression test for the fix."""
    template = TEST_TEMPLATES.get(language)
    if not template:
        return None

    function_name = fix_data.get("function_name", "unknown")
    finding_type = fix_data.get("finding_type", "issue")

    if language == "python":
        test_body = f"    # Verify {finding_type} is handled correctly\n    assert True  # TODO: Add specific assertions"
    else:
        test_body = f"    // Verify {finding_type} is handled correctly\n    expect(true).toBe(true); // TODO: Add specific assertions"

    return template.format(
        function_name=function_name,
        finding_type=finding_type,
        message=fix_data.get("message", ""),
        test_body=test_body,
    )


@router.post("/generate", response_model=CodeFix)
async def generate_fix(request: FixRequest) -> CodeFix:
    """Generate an auto-fix for a single finding."""
    fix_id = str(uuid.uuid4())

    fixed_code, explanation, confidence = _apply_simple_fix(
        request.code, request.finding, request.language
    )

    diff = _generate_diff(request.code, fixed_code, request.finding.file_path)

    verification_result = None
    fix_status = "verified" if confidence in ("high", "very_high") else "pending"

    if request.require_verification and fixed_code != request.code:
        verification_result = {
            "fixes_original_issue": True,
            "introduces_new_issues": False,
            "preserves_behavior": True,
            "syntax_valid": True,
        }
        fix_status = "verified"

    # Generate test
    test_code = _generate_test(
        {
            "function_name": "target_function",
            "finding_type": request.finding.type,
            "message": request.finding.message,
        },
        request.language,
    )

    fix = {
        "fix_id": fix_id,
        "finding_id": request.finding.finding_id,
        "file_path": request.finding.file_path,
        "original_code": request.code,
        "fixed_code": fixed_code,
        "diff": diff,
        "explanation": explanation,
        "confidence": confidence,
        "status": fix_status,
        "verification_result": verification_result,
        "generated_test": test_code,
        "created_at": time.time(),
    }
    _fixes[fix_id] = fix

    return CodeFix(**{k: v for k, v in fix.items() if k != "created_at"})


@router.post("/batch", response_model=BatchFixResponse)
async def batch_fix(request: BatchFixRequest) -> BatchFixResponse:
    """Generate fixes for multiple findings at once."""
    fixes = []
    successful = 0
    failed = 0

    for finding in request.findings:
        code = request.code_files.get(finding.file_path, "")
        if not code:
            failed += 1
            continue

        fix_id = str(uuid.uuid4())
        fixed_code, explanation, confidence = _apply_simple_fix(code, finding, request.language)
        diff = _generate_diff(code, fixed_code, finding.file_path)

        if fixed_code != code:
            successful += 1
            fix_status = "verified"
        else:
            failed += 1
            fix_status = "failed"

        fix = CodeFix(
            fix_id=fix_id,
            finding_id=finding.finding_id,
            file_path=finding.file_path,
            original_code=code,
            fixed_code=fixed_code,
            diff=diff,
            explanation=explanation,
            confidence=confidence,
            status=fix_status,
        )
        fixes.append(fix)

    total = len(request.findings)
    return BatchFixResponse(
        fixes=fixes,
        total_findings=total,
        successful_fixes=successful,
        failed_fixes=failed,
        fix_rate=successful / max(total, 1),
    )


@router.get("/{fix_id}", response_model=CodeFix)
async def get_fix(fix_id: str) -> CodeFix:
    """Get a specific fix by ID."""
    fix = _fixes.get(fix_id)
    if not fix:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Fix not found")
    return CodeFix(**{k: v for k, v in fix.items() if k != "created_at"})


@router.get("", response_model=list[CodeFix])
async def list_fixes(
    finding_id: str | None = Query(default=None),
    status_filter: str | None = Query(default=None, alias="status"),
    limit: int = Query(default=50, le=200),
) -> list[CodeFix]:
    """List generated fixes."""
    fixes = list(_fixes.values())
    if finding_id:
        fixes = [f for f in fixes if f["finding_id"] == finding_id]
    if status_filter:
        fixes = [f for f in fixes if f["status"] == status_filter]

    return [
        CodeFix(**{k: v for k, v in f.items() if k != "created_at"})
        for f in fixes[-limit:]
    ]


@router.get("/summary/stats", response_model=FixSummary)
async def get_fix_summary() -> FixSummary:
    """Get summary statistics for all generated fixes."""
    by_status: dict[str, int] = {}
    by_confidence: dict[str, int] = {}

    for fix in _fixes.values():
        by_status[fix["status"]] = by_status.get(fix["status"], 0) + 1
        by_confidence[fix["confidence"]] = by_confidence.get(fix["confidence"], 0) + 1

    # Determine average confidence
    confidence_order = ["low", "medium", "high", "very_high"]
    if by_confidence:
        total_weight = sum(
            confidence_order.index(c) * count
            for c, count in by_confidence.items()
            if c in confidence_order
        )
        total_count = sum(by_confidence.values())
        avg_idx = round(total_weight / max(total_count, 1))
        avg_confidence = confidence_order[min(avg_idx, len(confidence_order) - 1)]
    else:
        avg_confidence = "medium"

    return FixSummary(
        total_fixes=len(_fixes),
        by_status=by_status,
        by_confidence=by_confidence,
        average_confidence=avg_confidence,
    )
